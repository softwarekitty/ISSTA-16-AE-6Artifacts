package core.features;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.antlr.runtime.tree.CommonTree;

import parse.pcre.PCREParser;

/**
 * represents the number of each feature present
 *
 * contains feature analysis logic that is tightly coupled with the PCRE parser
 * interfaces (CommonTree), and with the FeatureDictionary class, which is
 * tightly coupled with the decisions of what features to include in the
 * analysis.
 * 
 * Changing any of those and wanting to be able to use this class in a frequency
 * analysis may require changes here.
 * 
 * @author cc
 */
public class FeatureCount {
	private static FeatureDictionary featureDictionary = new FeatureDictionary();
	private final int[] featureCountArray;

	/**
	 * main constructor
	 *
	 * creates a count of features from an array
	 * 
	 * @param featureCountArray
	 *            an array with length equal to the number of features in the
	 *            featureDictionary. Each array value represents the number of
	 *            features corresponding to the index for that feature in the
	 *            featureDictionary.
	 **/
	public FeatureCount(int[] arrayCountingFeatures) {
		int correctLength = featureDictionary.getSize();
		int actualLength = arrayCountingFeatures.length;
		if (actualLength != correctLength) {
			throw new IllegalArgumentException(
					"array must have length: " + correctLength + " but has length: " + actualLength);
		}
		for (int i = 0; i < correctLength; i++) {
			int countValue = arrayCountingFeatures[i];
			if (countValue < 0) {
				throw new IllegalArgumentException("feature counts must be positive or zero, but at index: " + i
						+ " the value given is: " + countValue);
			}
		}
		this.featureCountArray = arrayCountingFeatures;
	}

	/**
	 * creates a FeatureCount from a Map<Integer,Integer>
	 * 
	 * @param indexCountMap
	 *            maps indexes to count values. keys outside of the correct
	 *            range are ignored.
	 */
	public FeatureCount(Map<Integer, Integer> indexCountMap) {
		this(countMapToArray(indexCountMap));
	}

	/**
	 * constructor used to count features in Regexes
	 * 
	 * @param tree
	 *            The root of the CommonTree created by the PCRE parser
	 * @param pattern
	 *            The pattern being parsed, only used for debugging messages
	 * @throws AlienFeatureException
	 *             If the tree contains a feature outside of the studied feature
	 *             set.
	 */
	public FeatureCount(CommonTree tree, String pattern) throws AlienFeatureException {
		this(treeToIndexCountMap(tree, pattern));
	}

	public FeatureCount(Integer... keyList) {
		this(putOnesIntoMapForKeys(keyList));
	}

	// returns a defensive copy of the featureCountArray
	public int[] getFeatureCountArray() {
		int length = featureCountArray.length;
		int[] copy = new int[length];
		System.arraycopy(featureCountArray, 0, copy, 0, length);
		return copy;
	}

	// returns how many distinct features are present
	public int getDistinctFeatureCount() {
		int nDistinctFeatures = 0;
		for (int nParsedTokens : featureCountArray) {
			if (nParsedTokens > 0) {
				nDistinctFeatures++;
			}
		}
		return nDistinctFeatures;
	}

	// total number of feature tokens
	public int getTokenCount() {
		int tokenCount = 0;
		for (int nParsedTokens : featureCountArray) {
			tokenCount += nParsedTokens;
		}
		return tokenCount;
	}

	///////////// constructor helpers//////////////

	// puts values of 1 into a Map<Integer,Integer> for a list of keys
	private static Map<Integer, Integer> putOnesIntoMapForKeys(Integer[] keyList) {
		HashMap<Integer, Integer> counts = new HashMap<Integer, Integer>();
		for (Integer key : keyList) {
			counts.put(key, 1);
		}
		return counts;
	}

	// for convenience in testing you can just add one or two features to a map
	private static int[] countMapToArray(Map<Integer, Integer> indexCountMap) {
		int correctLength = featureDictionary.getSize();
		int[] array = new int[correctLength];
		Set<Entry<Integer, Integer>> entries = indexCountMap.entrySet();

		// ignores keys outside of the correct range
		for (Entry<Integer, Integer> entry : entries) {
			int proposedIndex = entry.getKey();
			if (proposedIndex >= 0 && proposedIndex < correctLength) {
				array[entry.getKey()] = entry.getValue();
			}
		}
		return array;
	}

	/*
	 * This is the important code for counting features. It walks the parse tree
	 * created by the PCRE parser and counts how many of each feature is
	 * present, creating a Map<Integer,Integer> that is used by the constructor
	 * of FeatureCount.
	 * 
	 * @param treeRoot The root of the parse tree generated by the PCRE parser.
	 * 
	 * @param pattern Passed in to provide context in debugging messages
	 * 
	 * @return A map going from feature indexes to the number of times they
	 * appear
	 * 
	 * @throws AlienFeatureException
	 */
	@SuppressWarnings("unchecked")
	private static Map<Integer, Integer> treeToIndexCountMap(CommonTree treeRoot, String pattern)
			throws AlienFeatureException {
		HashMap<Integer, Integer> indexCountMap = new HashMap<Integer, Integer>();

		List<CommonTree> firstStack = new ArrayList<CommonTree>();
		firstStack.add(treeRoot);

		List<List<CommonTree>> childListStack = new ArrayList<List<CommonTree>>();
		childListStack.add(firstStack);

		while (!childListStack.isEmpty()) {

			List<CommonTree> childStack = childListStack.get(childListStack.size() - 1);

			if (childStack.isEmpty()) {
				childListStack.remove(childListStack.size() - 1);
			} else {
				CommonTree subTree = childStack.remove(0);
				incrementCount(subTree, indexCountMap, pattern);
				if (subTree.getChildCount() > 0) {
					childListStack.add(new ArrayList<CommonTree>((List<CommonTree>) subTree.getChildren()));
				}
			}
		}
		return indexCountMap;
	}

	/**
	 * this method looks at a tree node, and if that node is a feature node, the
	 * count is adjusted to reflect the presence of this feature to get this to
	 * work, I added Repetition names to the PCREParser
	 * 
	 * @param tree
	 *            The current tree node being checked for feature status and
	 *            type.
	 * @param indexCountMap
	 *            The map tracking how many of each feature have been observed.
	 * @param pattern
	 *            The pattern being parsed, used only for debugging messages.
	 * @throws AlienFeatureException
	 */
	private static void incrementCount(CommonTree tree, Map<Integer, Integer> indexCountMap, String pattern)
			throws AlienFeatureException {

		// these tree nodes are branches of the parse tree, not leaves
		List<String> ignoreList = Arrays.asList("", "QUANTIFIER", "NUMBER", "GREEDY", "ALTERNATIVE", "ELEMENT", "NAME",
				"OPTION", "SET", "UNSET");

		// repetitions use the same name as the FeatureDictionary, so just use
		// those
		String tokenName = "";
		if (tree.getType() == PCREParser.REPETITION_TYPE) {
			tokenName = tree.getText();

			// otherwise, look up the tokenName
		} else {
			tokenName = PCREParser.tokenNames[tree.getType()];
		}
		int featureIndex = featureDictionary.getIndex(tokenName);

		// it is some valid feature index that maps directly
		if (featureIndex >= 0) {
			incrementIntIntMap(indexCountMap, featureIndex);

			// or it is not supported by the analysis
		} else if (!ignoreList.contains(tokenName)) {
			throw new AlienFeatureException(
					"found unsupported feature: " + PCREParser.tokenNames[tree.getType()] + " in pattern: " + pattern,
					PCREParser.tokenNames[tree.getType()]);
		}
	}

	private static void incrementIntIntMap(Map<Integer, Integer> map, int keyIndex) {
		Integer previousValue = map.get(keyIndex);
		if (previousValue == null) {
			map.put(keyIndex, 1);
		} else {
			map.put(keyIndex, previousValue + 1);
		}
	}

	////////////////// hashcode, string and equals////////////////

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(featureCountArray);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		FeatureCount other = (FeatureCount) obj;
		if (!Arrays.equals(featureCountArray, other.featureCountArray))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return "FeatureCount [featureCountArray=" + Arrays.toString(featureCountArray) + "]";
	}
}
